<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Realistic Driving Simulator</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #ffffff;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 5px;
            pointer-events: none;
            user-select: none;
            text-shadow: 1px 1px 2px #000;
        }
        #instructions {
            font-size: 14px;
            margin-top: 8px;
            color: #cccccc;
        }
    </style>
</head>
<body>
    <div id="info">
        <strong>REALISTIC DRIVING SIM : ACTIVE</strong><br>
        <div id="speed">Speed: 0 km/h</div>
        <div id="coords">X: 0 | Z: 0</div>
        <div id="instructions">
            [↑] 加速 / [↓] 減速・バック<br>
            [←] [→] ハンドル操作
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- 設定 ---
        const CONFIG = {
            blockSize: 100,
            roadWidth: 22,
            buildingDensity: 0.6,
            viewDistance: 5, // 描画距離
            fogColor: 0x8899aa, // 少し曇ったリアルな空色
            fogDensity: 0.0035,
            camHeight: 1.35,
        };

        // --- グローバル変数 ---
        let scene, camera, renderer;
        let carGroup, steeringWheel;
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
        
        const carState = {
            speed: 0, maxSpeed: 2.2, acceleration: 0.015, friction: 0.008,
            rotation: 0, steeringAngle: 0, x: 0, z: 0,
            vibration: 0
        };

        const cityChunks = new Map();
        const geometryPool = {
            road: new THREE.PlaneGeometry(CONFIG.blockSize, CONFIG.roadWidth),
        };
        let materialPool = {}; // initで初期化

        // --- ユーティリティ関数 (テクスチャ生成) ---
        // ノイズテクスチャ生成（アスファルトやダッシュボードの凹凸用）
        function createBumpTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            const imgData = ctx.createImageData(256, 256);
            for (let i = 0; i < imgData.data.length; i += 4) {
                const val = 100 + Math.random() * 155; // グレーのノイズ
                imgData.data[i] = val; imgData.data[i+1] = val; imgData.data[i+2] = val; imgData.data[i+3] = 255;
            }
            ctx.putImageData(imgData, 0, 0);
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(8, 8); // 細かくリピート
            return tex;
        }

        // ビル窓パターン生成
        function createBuildingTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            // 壁ベース色
            ctx.fillStyle = '#666677'; ctx.fillRect(0, 0, 64, 128);
            // 窓
            ctx.fillStyle = '#2a3344'; // 窓ガラス色
            ctx.strokeStyle = '#111111'; ctx.lineWidth = 2; // 窓枠
            for(let y=10; y<128; y+=24) {
                for(let x=8; x<64; x+=20) {
                     ctx.fillRect(x, y, 12, 16);
                     ctx.strokeRect(x,y,12,16);
                }
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
            // 建物の高さに応じてリピート調整が必要だが簡易的に設定
            tex.repeat.set(1, 4); 
            return tex;
        }
        
        init();
        animate();

        function init() {
            // シーン・フォグ
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.fogColor);
            // 距離に応じて指数関数的に濃くなるリアルな霧
            scene.fog = new THREE.FogExp2(CONFIG.fogColor, CONFIG.fogDensity);

            // カメラ
            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 500);
            
            // レンダラー (物理ベースレンダリングを有効化)
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // 柔らかい影
            renderer.toneMapping = THREE.ACESFilmicToneMapping; // 映画のようなトーンマッピング
            renderer.toneMappingExposure = 1.0;
            document.body.appendChild(renderer.domElement);

            // マテリアルの準備 (リアルな質感設定)
            const bumpTex = createBumpTexture();
            const buildingTex = createBuildingTexture();

            materialPool = {
                building: new THREE.MeshStandardMaterial({
                    map: buildingTex, roughness: 0.9, metalness: 0.1
                }),
                buildingReflective: new THREE.MeshStandardMaterial({
                    color: 0x8899aa, roughness: 0.1, metalness: 0.8, // ガラス質のビル
                    envMapIntensity: 1.5
                }),
                road: new THREE.MeshStandardMaterial({
                    color: 0x333344,
                    bumpMap: bumpTex, bumpScale: 0.8, // ザラザラ感
                    roughness: 0.95, metalness: 0.05
                }),
                line: new THREE.MeshBasicMaterial({ color: 0xeeeeee }),
                grass: new THREE.MeshStandardMaterial({ 
                    color: 0x335533, roughness: 1.0, bumpMap: bumpTex, bumpScale: 0.2
                })
            };

            // ライティング
            setupLights();

            // 車（コックピット）
            createCockpit(bumpTex);

            // 初期都市生成
            updateCityChunks();

            // イベント
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', (e) => { if(keys.hasOwnProperty(e.code)) keys[e.code] = true; });
            document.addEventListener('keyup', (e) => { if(keys.hasOwnProperty(e.code)) keys[e.code] = false; });
        }

        function setupLights() {
            // 環境光 (影の部分を青っぽくして空気感を出す)
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444455, 0.6);
            scene.add(hemiLight);

            // 太陽光
            const dirLight = new THREE.DirectionalLight(0xfff0dd, 1.5);
            dirLight.position.set(-150, 250, -100);
            dirLight.castShadow = true;
            // 影の品質設定
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.top = 300;
            dirLight.shadow.camera.bottom = -300;
            dirLight.shadow.camera.left = -300;
            dirLight.shadow.camera.right = 300;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 800;
            dirLight.shadow.bias = -0.0001;
            dirLight.shadow.radius = 2; // 影のエッジをぼかす
            scene.add(dirLight);
        }

        function createCockpit(bumpTex) {
            carGroup = new THREE.Group();
            scene.add(carGroup);
            carGroup.add(camera);
            camera.position.set(0, CONFIG.camHeight, 0);

            // 共通マテリアル：内装のダークグレー（レザー調の凹凸を追加）
            const interiorMat = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a1a, 
                roughness: 0.9, 
                metalness: 0.1,
                bumpMap: bumpTex,
                bumpScale: 0.015 // 細かいシボ感
            });

            // 1. ダッシュボード
            const dashboard = new THREE.Mesh(new THREE.BoxGeometry(2.8, 0.6, 1.2), interiorMat);
            dashboard.position.set(0, CONFIG.camHeight - 0.55, -0.7);
            dashboard.castShadow = true; // 車内にも影を落とす
            carGroup.add(dashboard);

            // 3. Aピラー (窓枠)
            const pillarGeo = new THREE.CylinderGeometry(0.05, 0.07, 1.6, 16);
            const leftPillar = new THREE.Mesh(pillarGeo, interiorMat);
            leftPillar.position.set(-1.2, CONFIG.camHeight + 0.35, -0.6);
            leftPillar.rotation.set(-0.25, 0, -0.15);
            carGroup.add(leftPillar);
            const rightPillar = leftPillar.clone();
            rightPillar.position.x *= -1;
            rightPillar.rotation.z *= -1;
            carGroup.add(rightPillar);

            // 4. 天井
            const roof = new THREE.Mesh(new THREE.BoxGeometry(2.8, 0.1, 1.8), interiorMat);
            roof.position.set(0, CONFIG.camHeight + 1.0, -0.2);
            carGroup.add(roof);

            // 5. ハンドル
            const wheelGroup = new THREE.Group();
            const rim = new THREE.Mesh(new THREE.TorusGeometry(0.28, 0.03, 16, 32), interiorMat);
            wheelGroup.add(rim);
            const spoke = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.05, 0.02), interiorMat);
            wheelGroup.add(spoke);
            wheelGroup.position.set(0.35, CONFIG.camHeight - 0.3, -0.6);
            wheelGroup.rotation.x = -0.4;
            carGroup.add(wheelGroup);
            steeringWheel = wheelGroup;

            // 6. ルームミラー (鏡面反射)
            const mirrorCaseMat = interiorMat;
            const mirrorFaceMat = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.05, metalness: 0.95 });
            const mirrorGeo = new THREE.BoxGeometry(0.45, 0.18, 0.05);
            const mirror = new THREE.Mesh(mirrorGeo, [mirrorCaseMat, mirrorCaseMat, mirrorCaseMat, mirrorCaseMat, mirrorFaceMat, mirrorCaseMat]);
            mirror.position.set(0, CONFIG.camHeight + 0.8, -0.4);
            mirror.rotation.x = 0.15;
            carGroup.add(mirror);
        }

        // --- 都市生成ロジック ---
        function pseudoRandom(x, z, salt = 0) {
            return ((Math.sin(x * 12.9898 + z * 78.233 + salt * 5.4321) * 43758.5453) % 1 + 1) % 1;
        }

function hashConnect(x1, z1, x2, z2) {
    const minX = Math.min(x1, x2);
    const maxX = Math.max(x1, x2);
    const minZ = Math.min(z1, z2);
    const maxZ = Math.max(z1, z2);
    // Use different salts for horizontal and vertical to add variety
    const salt = (x1 === x2) ? 1.1 : 2.2;
    return pseudoRandom(minX, minZ, maxX + maxZ + salt) > 0.45;
}

        function createOfficeBuilding(absX, absZ, relX, relZ) {
            const height = 60 + pseudoRandom(absX, absZ) * 120;
            const width = 25 + pseudoRandom(absX + 1, absZ) * 20;
            const depth = 25 + pseudoRandom(absX, absZ + 1) * 20;

            const geo = new THREE.BoxGeometry(width, height, depth);
            geo.translate(0, height / 2, 0);

            const mat = pseudoRandom(absX + 5, absZ + 5) > 0.5 
                ? materialPool.buildingReflective 
                : new THREE.MeshStandardMaterial({ 
                      color: 0x99aaff, 
                      roughness: 0.2, 
                      metalness: 0.7 
                  });

            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(relX, 0, relZ);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            return mesh;
        }

        function createUtilityPole(relX, relZ) {
            const group = new THREE.Group();
            const poleHeight = 12;
            const poleMat = new THREE.MeshStandardMaterial({ color: 0x4a4a4a, roughness: 0.8 });
            
            // 本体
            const poleGeo = new THREE.CylinderGeometry(0.2, 0.3, poleHeight, 8);
            const pole = new THREE.Mesh(poleGeo, poleMat);
            pole.position.y = poleHeight / 2;
            pole.castShadow = true;
            group.add(pole);

            // 横木
            const crossbarGeo = new THREE.BoxGeometry(0.3, 0.3, 3);
            const crossbar1 = new THREE.Mesh(crossbarGeo, poleMat);
            crossbar1.position.y = poleHeight - 2.5;
            group.add(crossbar1);
            
            const crossbar2 = crossbar1.clone();
            crossbar2.position.y = poleHeight - 4;
            group.add(crossbar2);
            
            group.position.set(relX, 0, relZ);
            return group;
        }

        function createApartment(absX, absZ, relX, relZ) {
            const height = 30 + pseudoRandom(absX, absZ) * 40;
            const width = 20 + pseudoRandom(absX + 1, absZ) * 10;
            const depth = 20 + pseudoRandom(absX, absZ + 1) * 10;
            
            const group = new THREE.Group();
            group.position.set(relX, 0, relZ);

            // 本体
            const mainMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.9 });
            const mainBuilding = new THREE.Mesh(new THREE.BoxGeometry(width, height, depth), mainMat);
            mainBuilding.position.y = height / 2;
            mainBuilding.castShadow = true;
            mainBuilding.receiveShadow = true;
            group.add(mainBuilding);

            // バルコニー
            const balconyMat = new THREE.MeshStandardMaterial({ color: 0xbbbbbb, roughness: 0.9 });
            const balconyGeo = new THREE.BoxGeometry(width, 1, 2);
            for (let y = 3; y < height - 3; y += 4) {
                const balcony = new THREE.Mesh(balconyGeo, balconyMat);
                balcony.position.set(0, y, depth / 2 + 1);
                balcony.castShadow = true;
                group.add(balcony);
            }
            return group;
        }

        function createBuilding(absX, absZ, relX, relZ) {
            const height = 20 + pseudoRandom(absX, absZ) * 60;
            const width = 15 + pseudoRandom(absX+1, absZ) * 15;
            const depth = 15 + pseudoRandom(absX, absZ+1) * 15;
            
            const geo = new THREE.BoxGeometry(width, height, depth);
            geo.translate(0, height / 2, 0);
            
            // ランダムで光沢のあるビルと窓テクスチャのビルを切り替え
            const mat = pseudoRandom(absX+5, absZ+5) > 0.8 ? materialPool.buildingReflective : materialPool.building;
            
            // テクスチャのリピート調整（高さに合わせて）
            if(mat.map) {
                 mat.map.repeat.set(width/20, height/30); 
                 mat.needsUpdate = true;
            }

            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(relX, 0, relZ);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            return mesh;
        }

        function createCrossroad(group, material) {
            const roadX = new THREE.Mesh(new THREE.PlaneGeometry(CONFIG.blockSize, CONFIG.roadWidth), material);
            roadX.rotation.x = -Math.PI / 2;
            roadX.position.y = 0.01;
            roadX.receiveShadow = true;
            group.add(roadX);

            const roadZ = roadX.clone();
            roadZ.rotation.z = Math.PI / 2;
            roadZ.position.y = 0.015;
            group.add(roadZ);
        }

        function createDeadEndRoad(group, material) {
            const road = new THREE.Mesh(new THREE.PlaneGeometry(CONFIG.blockSize / 2, CONFIG.roadWidth), material);
            road.rotation.x = -Math.PI / 2;
            road.position.set(-CONFIG.blockSize / 4, 0.01, 0);
            road.receiveShadow = true;
            group.add(road);
        }

        function createStraightRoad(group, material) {
            const road = new THREE.Mesh(new THREE.PlaneGeometry(CONFIG.blockSize, CONFIG.roadWidth), material);
            road.rotation.x = -Math.PI / 2;
            road.position.y = 0.01;
            road.receiveShadow = true;
            group.add(road);
        }

        function createTJunction(group, material) {
            const road1 = new THREE.Mesh(new THREE.PlaneGeometry(CONFIG.blockSize, CONFIG.roadWidth), material);
            road1.rotation.x = -Math.PI / 2;
            road1.position.y = 0.01;
            road1.receiveShadow = true;
            group.add(road1);

            const road2 = new THREE.Mesh(new THREE.PlaneGeometry(CONFIG.roadWidth, CONFIG.blockSize / 2), material);
            road2.rotation.x = -Math.PI / 2;
            road2.position.set(0, 0.015, -CONFIG.blockSize/4);
            road2.receiveShadow = true;
            group.add(road2);
        }

        function createCurve(group, material) {
            const curveShape = new THREE.Shape();
            const roadWidth = CONFIG.roadWidth;
            curveShape.moveTo(-CONFIG.blockSize / 2, -roadWidth / 2);
            curveShape.lineTo(-roadWidth / 2, -roadWidth / 2);
            curveShape.quadraticCurveTo(
                -roadWidth / 2, CONFIG.blockSize / 2,
                CONFIG.blockSize / 2, CONFIG.blockSize / 2
            );
             curveShape.lineTo(CONFIG.blockSize / 2, roadWidth/2);
             curveShape.quadraticCurveTo(
                roadWidth/2, roadWidth/2,
                roadWidth / 2, -CONFIG.blockSize / 2
            );
            curveShape.lineTo(-CONFIG.blockSize/2, -CONFIG.blockSize/2);


            const geometry = new THREE.ShapeGeometry(curveShape);
            const road = new THREE.Mesh(geometry, material);
            road.rotation.x = -Math.PI / 2;
            road.position.y = 0.01;
            road.receiveShadow = true;
            group.add(road);
        }

        function createChunk(cx, cz) {
            const chunkGroup = new THREE.Group();
            const baseX = cx * CONFIG.blockSize;
            const baseZ = cz * CONFIG.blockSize;
            chunkGroup.position.set(baseX, 0, baseZ);

            const ground = new THREE.Mesh(new THREE.PlaneGeometry(CONFIG.blockSize, CONFIG.blockSize), materialPool.grass);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.05;
            ground.receiveShadow = true;
            chunkGroup.add(ground);

            // --- 道路生成ロジック (決定的バージョン) ---
            const connections = {
                north: hashConnect(cx, cz, cx, cz + 1),
                east: hashConnect(cx, cz, cx + 1, cz),
                south: hashConnect(cx, cz, cx, cz - 1),
                west: hashConnect(cx, cz, cx - 1, cz)
            };
            
            // スタート地点(0,0)とその隣接チャンクは必ず道路を接続し、スタート地点を十字路にする
            if (cx === 0 && cz === 0) {
                connections.north = connections.east = connections.south = connections.west = true;
            } else if (cx === 0 && cz === 1) {
                connections.south = true;
            } else if (cx === 1 && cz === 0) {
                connections.west = true;
            } else if (cx === 0 && cz === -1) {
                connections.north = true;
            } else if (cx === -1 && cz === 0) {
                connections.east = true;
            }

            const connectionCount = Object.values(connections).filter(Boolean).length;
            const roadMaterial = materialPool.road;

            if (connectionCount === 4) {
                createCrossroad(chunkGroup, roadMaterial);
            } else if (connectionCount === 3) {
                createTJunction(chunkGroup, roadMaterial);
                if (!connections.north) chunkGroup.rotation.y = Math.PI;
                else if (!connections.east) chunkGroup.rotation.y = -Math.PI / 2;
                else if (!connections.west) chunkGroup.rotation.y = Math.PI / 2;
            } else if (connectionCount === 2) {
                if (connections.north && connections.south) {
                    createStraightRoad(chunkGroup, roadMaterial);
                } else if (connections.east && connections.west) {
                    createStraightRoad(chunkGroup, roadMaterial);
                    chunkGroup.rotation.y = Math.PI / 2;
                } else {
                    createCurve(chunkGroup, roadMaterial);
                    if (connections.north && connections.west) chunkGroup.rotation.y = Math.PI / 2;
                    else if (connections.south && connections.west) chunkGroup.rotation.y = Math.PI;
                    else if (connections.south && connections.east) chunkGroup.rotation.y = -Math.PI / 2;
                }
            } else if (connectionCount === 1) {
                createDeadEndRoad(chunkGroup, roadMaterial);
                 if (connections.north) chunkGroup.rotation.y = Math.PI / 2;
                 else if (connections.east) chunkGroup.rotation.y = Math.PI;
                 else if (connections.south) chunkGroup.rotation.y = -Math.PI / 2;
            }
            // connectionCountが0の場合は道路なし（広場）
            
            // 電柱の配置
            for(let i = -CONFIG.blockSize / 2; i <= CONFIG.blockSize / 2; i += 25) {
                if (Math.abs(i) > CONFIG.roadWidth / 2 - 5) {
                     chunkGroup.add(createUtilityPole(i, CONFIG.roadWidth / 2 + 2));
                     chunkGroup.add(createUtilityPole(i, -CONFIG.roadWidth / 2 - 2));
                }
            }

            // ビル配置
            const qSize = CONFIG.blockSize / 4;
            [[ -1, -1 ], [ 1, -1 ], [ -1, 1 ], [ 1, 1 ]].forEach(([qx, qz]) => {
                const relX = qx * qSize * 1.5;
                const relZ = qz * qSize * 1.5;
                // ビルの存在確率と形状は絶対座標に基づいて決定（チャンクの回転に影響されないように）
                const absX = baseX + relX;
                const absZ = baseZ + relZ;

                if(pseudoRandom(absX, absZ) < CONFIG.buildingDensity) {
                    const dist = Math.sqrt(absX*absX + absZ*absZ);
                    const buildingTypeRand = pseudoRandom(absX + 2, absZ - 2);

                    let building;
                    if (dist < 500) { // Downtown
                        if (buildingTypeRand < 0.8) {
                            building = createOfficeBuilding(absX, absZ, relX, relZ);
                        } else {
                            building = createApartment(absX, absZ, relX, relZ);
                        }
                    } else if (dist < 1500) { // Midtown
                        if (buildingTypeRand < 0.4) {
                             building = createOfficeBuilding(absX, absZ, relX, relZ);
                        } else if (buildingTypeRand < 0.9) {
                            building = createApartment(absX, absZ, relX, relZ);
                        } else {
                            building = createBuilding(absX, absZ, relX, relZ);
                        }
                    } else { // Suburbs
                        if (buildingTypeRand < 0.7) {
                            building = createApartment(absX, absZ, relX, relZ);
                        } else {
                            building = createBuilding(absX, absZ, relX, relZ);
                        }
                    }
                    chunkGroup.add(building);
                }
            });

            scene.add(chunkGroup);
            return chunkGroup;
        }

        function updateCityChunks() {
            const cx = Math.round(carState.x / CONFIG.blockSize);
            const cz = Math.round(carState.z / CONFIG.blockSize);
            const activeKeys = new Set();

            for (let x = cx - CONFIG.viewDistance; x <= cx + CONFIG.viewDistance; x++) {
                for (let z = cz - CONFIG.viewDistance; z <= cz + CONFIG.viewDistance; z++) {
                    const key = `${x},${z}`;
                    activeKeys.add(key);
                    if (!cityChunks.has(key)) cityChunks.set(key, createChunk(x, z));
                }
            }
            for (const [key, mesh] of cityChunks) {
                if (!activeKeys.has(key)) {
                    scene.remove(mesh);
                    cityChunks.delete(key);
                }
            }
        }

        function updateCar() {
            // 物理挙動
            if (keys.ArrowUp) carState.speed += carState.acceleration;
            else if (keys.ArrowDown) carState.speed -= carState.acceleration;
            else carState.speed -= Math.sign(carState.speed) * carState.friction;
            
            carState.speed = Math.max(-carState.maxSpeed/2, Math.min(carState.maxSpeed, carState.speed));
            if(Math.abs(carState.speed) < 0.001) carState.speed = 0;

            const turnFactor = Math.min(Math.abs(carState.speed) / 0.5, 1.0);
            if (keys.ArrowLeft) carState.steeringAngle += 0.06 * turnFactor;
            else if (keys.ArrowRight) carState.steeringAngle -= 0.06 * turnFactor;
            else carState.steeringAngle -= Math.sign(carState.steeringAngle) * 0.08 * turnFactor;
            carState.steeringAngle = Math.max(-1.0, Math.min(1.0, carState.steeringAngle));

            carState.rotation += carState.steeringAngle * carState.speed * 0.015;
            carState.x -= Math.sin(carState.rotation) * carState.speed;
            carState.z -= Math.cos(carState.rotation) * carState.speed;

            carGroup.position.set(carState.x, 0, carState.z);
            carGroup.rotation.y = carState.rotation;

            // 振動エフェクト（速度に応じて）
            carState.vibration = (Math.random() - 0.5) * carState.speed * 0.003;
            if(steeringWheel) {
                steeringWheel.rotation.z = carState.steeringAngle * 2.2;
                steeringWheel.position.y = (CONFIG.camHeight - 0.3) + carState.vibration;
            }
            // カメラもわずかに振動させて臨場感を出す
            camera.position.y = CONFIG.camHeight + carState.vibration * 0.5;

            // HUD更新
            document.getElementById('speed').innerText = `Speed: ${Math.abs(Math.round(carState.speed * 50))} km/h`;
            document.getElementById('coords').innerText = `X: ${Math.round(carState.x)} | Z: ${Math.round(carState.z)}`;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            updateCar();
            updateCityChunks();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
