<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>vroom</title>
    <style>
        body { margin: 0; overflow: hidden; background: #111; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .top-bar {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }

        #score-box {
            color: #ffcc00;
            font-size: 24px;
            font-weight: 900;
            text-shadow: 0 0 10px #ffcc00;
            font-style: italic;
        }

        #help-box {
            color: rgba(255,255,255,0.8);
            text-align: right;
            font-size: 12px;
            line-height: 1.5;
        }

        .dashboard {
            display: flex;
            align-items: flex-end;
            padding: 30px;
            gap: 40px;
            background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
        }

        .gauge-container {
            position: relative;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: 4px solid #333;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .gauge-value {
            color: #fff;
            font-size: 32px;
            font-weight: bold;
            font-style: italic;
        }
        .gauge-label {
            position: absolute;
            bottom: 20px;
            font-size: 10px;
            color: #888;
        }
        .gear-display {
            font-size: 40px;
            color: #0ff;
            font-weight: 900;
            text-shadow: 0 0 10px #0ff;
        }

        #drift-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 40px;
            color: #ff3366;
            font-weight: 900;
            text-transform: uppercase;
            font-style: italic;
            opacity: 0;
            transition: opacity 0.2s;
            text-shadow: 4px 4px 0 #000;
        }

        .key {
            display: inline-block;
            background: #333;
            color: #fff;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 10px;
            margin: 0 2px;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="top-bar">
            <div id="score-box">SCORE: <span id="score-val">0</span></div>
            <div id="help-box">
                <span class="key">W</span> アクセル <span class="key">S</span> ブレーキ/バック<br>
                <span class="key">A</span> <span class="key">D</span> ステアリング<br>
                <span class="key">SPACE</span> ハンドブレーキ(ドリフト)<br>
                <span class="key">T</span> 時間変更 (昼/夕/夜)<br>
                <span class="key">R</span> リセット<br>
                <span class="key">M</span> ギアモード <span class="key">Q</span><span class="key">E</span> シフト
            </div>
        </div>

        <div id="drift-msg">DRIFT!</div>

        <div class="dashboard">
            <div style="text-align: center;">
                <div class="gear-display" id="disp-gear">N</div>
                <div style="color:#aaa; font-size:10px;">GEAR</div>
                <div id="disp-gear-mode" style="color:#aaa; font-size:10px; margin-top: 5px;">AUTO</div>
            </div>

            <div class="gauge-container">
                <div class="gauge-value" id="disp-speed">0</div>
                <div class="gauge-label">KM/H</div>
                <div id="rpm-bar" style="position:absolute; bottom:0; left:0; height:4px; background:#f00; width:0%; transition: width 0.1s;"></div>
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        const TILE_SIZE = 50; 
        const WORLD_OFFSET_X = -400;
        const WORLD_OFFSET_Z = -400;
        
        // 0:道路, 1:民家, 2:店舗/ビル, 3:田畑/空き地, 4:林, 9:スタート
        const mapData = [
            [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4],
            [4,1,3,1,0,3,3,2,0,1,1,3,3,4,4,4],
            [4,1,1,3,0,1,1,1,0,3,1,2,1,4,4,4],
            [4,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4],
            [4,3,2,0,3,3,1,0,3,2,1,1,0,4,4,4],
            [4,1,1,0,1,1,3,0,1,1,3,3,0,4,4,4],
            [4,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4],
            [4,1,3,0,3,4,4,0,3,1,9,1,0,4,4,4],
            [4,2,2,0,4,4,4,0,1,1,0,0,0,4,4,4],
            [4,3,3,0,3,3,1,0,2,2,0,3,3,4,4,4],
            [4,0,0,0,0,0,0,0,0,0,0,1,1,4,4,4],
            [4,1,1,3,1,0,3,3,1,0,3,3,1,4,4,4],
            [4,3,3,3,2,0,1,1,2,0,1,1,3,4,4,4],
            [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4],
        ];

        function createTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');

            if (type === 'road') {
                ctx.fillStyle = '#333'; ctx.fillRect(0,0,256,256);
                addNoise(ctx, 256, 256, 0.05);
                ctx.fillStyle = '#ddd'; ctx.fillRect(126, 0, 4, 256);
                ctx.fillStyle = '#fff'; ctx.fillRect(10, 0, 4, 256); ctx.fillRect(242, 0, 4, 256);
            } else if (type === 'grass') {
                ctx.fillStyle = '#2d5a27'; ctx.fillRect(0,0,256,256);
                addNoise(ctx, 256, 256, 0.2);
            } else if (type === 'wall') {
                ctx.fillStyle = '#e0d5c1'; ctx.fillRect(0,0,256,256);
                ctx.fillStyle = '#4a5c66';
                for(let y=20; y<256; y+=60) for(let x=20; x<256; x+=50) ctx.fillRect(x, y, 30, 40);
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        function addNoise(ctx, w, h, alpha) {
            const id = ctx.getImageData(0,0,w,h);
            const d = id.data;
            for(let i=0; i<d.length; i+=4) {
                const r = Math.random() * 255;
                d[i] = d[i]*(1-alpha) + r*alpha;
                d[i+1] = d[i+1]*(1-alpha) + r*alpha;
                d[i+2] = d[i+2]*(1-alpha) + r*alpha;
            }
            ctx.putImageData(id, 0, 0);
        }

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0xaaccff, 0.003);
        scene.background = new THREE.Color(0xaaccff);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const texRoad = createTexture('road');
        const texGrass = createTexture('grass');
        const texWall = createTexture('wall');

        const matRoad = new THREE.MeshStandardMaterial({ map: texRoad, roughness: 0.8 });
        const matGrass = new THREE.MeshStandardMaterial({ map: texGrass, roughness: 1.0 });
        const matWall = new THREE.MeshStandardMaterial({ map: texWall });
        const matRoof = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
        const matTree = new THREE.MeshStandardMaterial({ color: 0x004400 });
        const matTrunk = new THREE.MeshStandardMaterial({ color: 0x553311 });
        const matOrb = new THREE.MeshBasicMaterial({ color: 0xffff00 });

        const colliders = [];
        const orbs = [];

        const sea = new THREE.Mesh(new THREE.PlaneGeometry(3000, 3000), new THREE.MeshBasicMaterial({ color: 0x001133 }));
        sea.rotation.x = -Math.PI/2; sea.position.y = -40; scene.add(sea);

        const mapW = mapData[0].length * TILE_SIZE;
        const mapH = mapData.length * TILE_SIZE;
        const island = new THREE.Mesh(new THREE.BoxGeometry(mapW, 40, mapH), new THREE.MeshStandardMaterial({ color: 0x444444 }));
        island.position.set(mapW/2 + WORLD_OFFSET_X - TILE_SIZE/2, -20, mapH/2 + WORLD_OFFSET_Z - TILE_SIZE/2);
        scene.add(island);

        function generateWorld() {
            for(let z=0; z<mapData.length; z++) {
                for(let x=0; x<mapData[z].length; x++) {
                    const type = mapData[z][x];
                    const px = x * TILE_SIZE + WORLD_OFFSET_X;
                    const pz = z * TILE_SIZE + WORLD_OFFSET_Z;

                    if(type !== 0 && type !== 9) {
                        const g = new THREE.Mesh(new THREE.PlaneGeometry(TILE_SIZE, TILE_SIZE), matGrass);
                        g.rotation.x = -Math.PI/2; g.position.set(px, 0.1, pz); g.receiveShadow = true; scene.add(g);
                    }
                    if (type === 0 || type === 9) {
                        const r = new THREE.Mesh(new THREE.PlaneGeometry(TILE_SIZE, TILE_SIZE), matRoad);
                        r.rotation.x = -Math.PI/2;
                        if ((x+z)%2 === 0) r.rotation.z = Math.PI/2;
                        r.position.set(px, 0.15, pz); r.receiveShadow = true; scene.add(r);

                        if(Math.random() < 0.3 && type !== 9) {
                            const orb = new THREE.Mesh(new THREE.SphereGeometry(1, 16, 16), matOrb);
                            orb.position.set(px + (Math.random()-0.5)*20, 1.5, pz + (Math.random()-0.5)*20);
                            scene.add(orb); orbs.push(orb);
                            const pLight = new THREE.PointLight(0xffff00, 1, 10);
                            pLight.position.copy(orb.position); scene.add(pLight);
                            orb.userData = { light: pLight, active: true };
                        }
                    } else if (type === 1 || type === 2) {
                        const h = type===1 ? 8 + Math.random()*5 : 15 + Math.random()*10;
                        const b = new THREE.Mesh(new THREE.BoxGeometry(TILE_SIZE-10, h, TILE_SIZE-10), matWall);
                        b.position.set(px, h/2, pz); b.castShadow = true; b.receiveShadow = true; scene.add(b);
                        const roof = new THREE.Mesh(new THREE.ConeGeometry((TILE_SIZE-8)/Math.sqrt(2), 6, 4), matRoof);
                        roof.position.set(px, h + 3, pz); roof.rotation.y = Math.PI/4; scene.add(roof);
                        colliders.push({minX: px-(TILE_SIZE-10)/2, maxX: px+(TILE_SIZE-10)/2, minZ: pz-(TILE_SIZE-10)/2, maxZ: pz+(TILE_SIZE-10)/2});
                    } else if (type === 4) {
                        for(let i=0; i<3; i++) {
                            const tx = px + (Math.random()-0.5)*30; const tz = pz + (Math.random()-0.5)*30;
                            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.8, 3), matTrunk);
                            trunk.position.set(tx, 1.5, tz); scene.add(trunk);
                            const leaves = new THREE.Mesh(new THREE.ConeGeometry(3, 8, 8), matTree);
                            leaves.position.set(tx, 6, tz); leaves.castShadow = true; scene.add(leaves);
                        }
                        colliders.push({minX: px-20, maxX: px+20, minZ: pz-20, maxZ: pz+20});
                    }
                }
            }
        }
        generateWorld();

        const carGroup = new THREE.Group();
        const carBodyGroup = new THREE.Group();
        carBodyGroup.rotation.y = Math.PI;
        carGroup.add(carBodyGroup);

        const chassis = new THREE.Mesh(new THREE.BoxGeometry(1.9, 0.7, 4.4), new THREE.MeshStandardMaterial({ color: 0xeeeeee, metalness: 0.7, roughness: 0.1 }));
        chassis.position.y = 0.6; chassis.castShadow = true; carBodyGroup.add(chassis);
        
        const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.7, 0.6, 2.5), new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.0 }));
        cabin.position.set(0, 1.2, -0.2); carBodyGroup.add(cabin);
        
        const spoiler = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.1, 0.4), new THREE.MeshStandardMaterial({ color: 0x111111 }));
        spoiler.position.set(0, 1.1, 2.0); carBodyGroup.add(spoiler);

        const headLightL = new THREE.SpotLight(0xffffee, 0); 
        headLightL.angle = Math.PI / 6; headLightL.penumbra = 0.2; headLightL.distance = 100; headLightL.decay = 2;
        headLightL.position.set(0.6, 0.7, -2.0); headLightL.target.position.set(0.6, 0.5, -10);
        carBodyGroup.add(headLightL); carBodyGroup.add(headLightL.target);
        
        const headLightR = headLightL.clone();
        headLightR.position.set(-0.6, 0.7, -2.0); headLightR.target.position.set(-0.6, 0.5, -10);
        carBodyGroup.add(headLightR); carBodyGroup.add(headLightR.target);
        scene.add(carGroup);

        let startX=0, startZ=0;
        mapData.forEach((row, z) => row.forEach((type, x) => {
            if(type===9){ startX = x*TILE_SIZE+WORLD_OFFSET_X; startZ = z*TILE_SIZE+WORLD_OFFSET_Z; }
        }));
        
        const carPhysics = {
            speed: 0,
            maxSpeed: 2.2,
            accel: 0.03,
            brake: 0.08,
            friction: 0.985,
            angle: Math.PI,
            driftAngle: 0,
            slide: 0,
            isDrifting: false,
            isFalling: false,
            fallVel: 0,
            isManualGear: false,
            currentGear: 0, // 0:N, -1:R, 1-3:Fwd
        };

        function resetCar() {
            carGroup.position.set(startX, 0.5, startZ);
            carGroup.rotation.set(0, Math.PI, 0);
            carPhysics.speed = 0;
            carPhysics.driftAngle = 0;
            carPhysics.slide = 0;
            carPhysics.isFalling = false;
            carPhysics.fallVel = 0;
        }
        resetCar();

        const GEAR_MAX_SPEED = {'-1': 0.8, '0': 0, '1': 0.8, '2': 1.6, '3': 2.2};

        const keys = { w:false, a:false, s:false, d:false, space:false, q:false, e:false };
        document.addEventListener('keydown', e => {
            const k = e.key.toLowerCase();
            if(keys.hasOwnProperty(k) || k===' ') keys[k===' '?'space':k] = true;
            if(k==='arrowup') keys.w = true; if(k==='arrowdown') keys.s = true;
            if(k==='arrowleft') keys.a = true; if(k==='arrowright') keys.d = true;
            if(k==='r') resetCar();
            if(k==='t') toggleTime();
            if(k==='m') carPhysics.isManualGear = !carPhysics.isManualGear;
            if(carPhysics.isManualGear) {
                if(k==='e' && carPhysics.currentGear < 3) carPhysics.currentGear++;
                if(k==='q' && carPhysics.currentGear > -1) carPhysics.currentGear--;
            }
        });
        document.addEventListener('keyup', e => {
            const k = e.key.toLowerCase();
            if(keys.hasOwnProperty(k) || k===' ') keys[k===' '?'space':k] = false;
            if(k==='arrowup') keys.w = false; if(k==='arrowdown') keys.s = false;
            if(k==='arrowleft') keys.a = false; if(k==='arrowright') keys.d = false;
        });

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); scene.add(ambientLight);
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
        sunLight.position.set(100, 200, 100); sunLight.castShadow = true;
        sunLight.shadow.mapSize.set(2048, 2048);
        sunLight.shadow.camera.left = -300; sunLight.shadow.camera.right = 300;
        sunLight.shadow.camera.top = 300; sunLight.shadow.camera.bottom = -300;
        scene.add(sunLight);

        let timeState = 0; 
        function toggleTime() {
            timeState = (timeState + 1) % 3;
            if(timeState === 0) {
                scene.background.setHex(0xaaccff); scene.fog.color.setHex(0xaaccff);
                ambientLight.intensity = 0.6; sunLight.intensity = 1.2; sunLight.color.setHex(0xffffff);
                headLightL.intensity = 0; headLightR.intensity = 0;
            } else if(timeState === 1) {
                scene.background.setHex(0xffaa66); scene.fog.color.setHex(0xffaa66);
                ambientLight.intensity = 0.4; sunLight.intensity = 0.8; sunLight.color.setHex(0xffaa00);
                headLightL.intensity = 10; headLightR.intensity = 10;
            } else {
                scene.background.setHex(0x050510); scene.fog.color.setHex(0x050510);
                ambientLight.intensity = 0.1; sunLight.intensity = 0.0;
                headLightL.intensity = 100; headLightR.intensity = 100;
            }
        }

        let score = 0;
        function updatePhysics() {
            if(carPhysics.isFalling) {
                carPhysics.fallVel += 0.02;
                carGroup.position.y -= carPhysics.fallVel;
                carGroup.rotation.x += 0.05; carGroup.rotation.z += 0.02;
                if(carGroup.position.y < -50) resetCar();
                return;
            }

            if (carPhysics.isManualGear) {
                const maxGearSpeed = GEAR_MAX_SPEED[carPhysics.currentGear];
                if (carPhysics.currentGear === -1) { // Reverse
                    if (keys.s) carPhysics.speed -= carPhysics.accel;
                    if (keys.w) carPhysics.speed += carPhysics.brake;
                    if (carPhysics.speed > 0) carPhysics.speed = 0;
                    if (carPhysics.speed < -maxGearSpeed) carPhysics.speed = -maxGearSpeed;
                } else { // Forward or Neutral
                    if (keys.w && carPhysics.currentGear > 0) carPhysics.speed += carPhysics.accel;
                    if (keys.s) carPhysics.speed -= carPhysics.brake;
                    if (carPhysics.speed < 0) carPhysics.speed = 0;
                    if (carPhysics.speed > maxGearSpeed) carPhysics.speed = maxGearSpeed;
                }
            } else { // Automatic
                if (keys.w) carPhysics.speed += carPhysics.accel;
                if (keys.s) carPhysics.speed -= carPhysics.brake;
                if (carPhysics.speed > carPhysics.maxSpeed) carPhysics.speed = carPhysics.maxSpeed;
                if (carPhysics.speed < -0.8) carPhysics.speed = -0.8;
            }
            carPhysics.speed *= carPhysics.friction;

            let steer = 0;
            if(Math.abs(carPhysics.speed) > 0.05) {
                if(keys.a) steer = 0.04; if(keys.d) steer = -0.04;
                if(carPhysics.speed < 0) steer *= -1;
            }
            carPhysics.angle += steer;

            let centrifugal = carPhysics.speed * steer * 5; 
            if (keys.space && Math.abs(carPhysics.speed) > 0.8) {
                carPhysics.slide += centrifugal * 1.5;
            } else {
                carPhysics.slide *= 0.9;
            }
            carPhysics.slide = Math.max(-1.5, Math.min(1.5, carPhysics.slide));

            const moveAngle = carPhysics.angle + carPhysics.slide * 0.5;
            const velX = Math.sin(moveAngle) * carPhysics.speed;
            const velZ = Math.cos(moveAngle) * carPhysics.speed;
            const nextX = carGroup.position.x + velX;
            const nextZ = carGroup.position.z + velZ;

            let collision = false; const carRad = 1.2;
            for(let c of colliders) {
                if(nextX+carRad > c.minX && nextX-carRad < c.maxX && nextZ+carRad > c.minZ && nextZ-carRad < c.maxZ) {
                    collision = true; break;
                }
            }
            if(collision) { carPhysics.speed *= -0.5; carPhysics.slide = 0; }
            else { carGroup.position.x = nextX; carGroup.position.z = nextZ; }
            carGroup.rotation.y = carPhysics.angle;

            const minX = WORLD_OFFSET_X - 10; const maxX = WORLD_OFFSET_X + mapW - TILE_SIZE + 10;
            const minZ = WORLD_OFFSET_Z - 10; const maxZ = WORLD_OFFSET_Z + mapH - TILE_SIZE + 10;
            if (nextX < minX || nextX > maxX || nextZ < minZ || nextZ > maxZ) carPhysics.isFalling = true;

            orbs.forEach(orb => {
                if(orb.userData.active) {
                    if(Math.hypot(orb.position.x - carGroup.position.x, orb.position.z - carGroup.position.z) < 3.0) {
                        score += 100; document.getElementById('score-val').innerText = score;
                        orb.userData.active = false; orb.visible = false; orb.userData.light.intensity = 0;
                    } else {
                        orb.position.y = 1.5 + Math.sin(Date.now()*0.005)*0.3; orb.rotation.y += 0.05;
                    }
                }
            });

            const roll = -carPhysics.slide * 0.2; 
            const pitch = (keys.w ? -0.02 : 0) + (keys.s ? 0.03 : 0);
            carBodyGroup.rotation.z += (roll - carBodyGroup.rotation.z) * 0.1;
            carBodyGroup.rotation.x += (pitch - carBodyGroup.rotation.x) * 0.1;

            const driftMsg = document.getElementById('drift-msg');
            if(Math.abs(carPhysics.slide) > 0.5 && Math.abs(carPhysics.speed) > 0.5) {
                driftMsg.style.opacity = 1;
                driftMsg.style.transform = `translate(-50%, -50%) rotate(${Math.random()*10-5}deg)`;
            } else { driftMsg.style.opacity = 0; }
        }

        function updateCamera() {
            if(carPhysics.isFalling) return;
            const dist = 6.0; const height = 2.5;
            
            const targetY = carGroup.position.y; 

            const camAngle = carPhysics.angle - carPhysics.slide * 0.3;
            const targetX = carGroup.position.x - Math.sin(camAngle) * dist;
            const targetZ = carGroup.position.z - Math.cos(camAngle) * dist;
            
            camera.position.x += (targetX - camera.position.x) * 0.1;
            camera.position.z += (targetZ - camera.position.z) * 0.1;
            camera.position.y += (targetY + height - camera.position.y) * 0.1;
            
            camera.lookAt(carGroup.position.x + Math.sin(carPhysics.angle)*10, carGroup.position.y+1, carGroup.position.z + Math.cos(carPhysics.angle)*10);
            camera.fov = 60 + Math.abs(carPhysics.speed) * 10;
            camera.updateProjectionMatrix();
        }

        function updateUI() {
            document.getElementById('disp-speed').innerText = Math.abs(Math.round(carPhysics.speed * 180));
            const ratio = Math.min(Math.abs(carPhysics.speed) / carPhysics.maxSpeed, 1.0);
            document.getElementById('rpm-bar').style.width = (ratio * 100) + '%';
            
            document.getElementById('disp-gear-mode').innerText = carPhysics.isManualGear ? 'MANUAL' : 'AUTO';
            let g = 'N';
            if(carPhysics.isManualGear) {
                if(carPhysics.currentGear === -1) g = 'R';
                else if(carPhysics.currentGear > 0) g = String(carPhysics.currentGear);
            } else {
                if(carPhysics.speed > 0.1) g = '1'; if(carPhysics.speed > 0.8) g = '2'; if(carPhysics.speed > 1.6) g = '3';
                if(carPhysics.speed < -0.1) g = 'R';
            }
            document.getElementById('disp-gear').innerText = g;
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics(); updateCamera(); updateUI();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
